<!DOCTYPE html>
<html lang="sv">

<head>
    <meta charset="utf-8">
    <title> Train Model</title>
    <link rel="stylesheet" href="../css/chessboard-1.0.0.min.css">
    <style type="text/css">
        body {
            background-color: lightgreen;
        }
    </style>
</head>

<body id="body">
    <!-- own scripts -->
    <script src="../js/fenToArray.js"></script>
    <script src="../js/arrayToFen.js"></script>
    <script src="../js/pgnToArray.js"></script>
    <!-- jquery -->
    <script src="../js/jquery-3.5.1.min.js"></script>
    <!-- chessboard.js -->
    <script src="../js/chessboard-1.0.0.min.js"></script>
    <!-- chess.js -->
    <script src="../js/chess.js"></script>
    <!-- tensorflow.js -->
    <!--<script src="tensorflowjs/tfjs/dist/tf.js"></script>-->
    <!-- use .min later maybe dunno -->
    <script src='../scripts/tf.min.js'></script>

    <div id="board" style="width: 400px"></div>
    <button id="startTheTraining">Train</button>
    <button id="CreatedNewModels">Create new Model</button>
    <button id="startTheTraining">Load Model</button>
    <button id="playBestMove">Play best Move</button>
    <button id="predictBestMove">Predict best move</button>

    <br><br>

    <button id="updateBoard">Update Board</button>
    <script>
        let leafMoves = []; //array for storing the leaf moves in the monte carlo tree search algorithm
        let bestMoveIndex = 0; //stores the index for the best root move so far
        let bestMoveValue = -1; //stores the value for the best prediction so far
        let possibleMovesMonte; //possibleMoves but as a global variable for the monte carlo tree search
        let boardBeforeMonte;


        var game = new Chess();
        let board = Chessboard('board', 'start');
        let neuralNetFinalArray = [];

        const inputLayer = tf.layers.dense({
            inputShape: 69,
            units: 10,
            activation: 'relu'
        });

        const hiddenLayer2 = tf.layers.dense({
            //inputShape: 69,
            units: 150,
            activation: 'relu'
        });

        const hiddenLayer3 = tf.layers.dense({
            //inputShape: 150,
            units: 100,
            activation: 'relu'
        });

        const hiddenLayer4 = tf.layers.dense({
            //inputShape: 100,
            units: 80,
            activation: 'relu'
        });

        const hiddenLayer5 = tf.layers.dense({
            //inputShape: 80,
            units: 60,
            activation: 'relu'
        });

        const hiddenLayer6 = tf.layers.dense({
            //inputShape: 60,
            units: 50,
            activation: 'relu'
        });


        const hiddenLayer7 = tf.layers.dense({
            //inputShape: 50,
            units: 25,
            activation: 'relu'
        });

        const outputLayer = tf.layers.dense({
            units: 1,
            activation: 'softmax'
        });

        const model = tf.sequential();
        model.add(inputLayer);
        model.add(hiddenLayer2);
        model.add(hiddenLayer3);
        model.add(hiddenLayer4);
        model.add(hiddenLayer5);
        model.add(hiddenLayer6);
        model.add(hiddenLayer7);
        model.add(outputLayer);
        model.compile({
            optimizer: 'sgd',
            loss: 'meanSquaredError'
        })

        /*async function createTrainingData(gameIndex) {
            game.load('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'); //starting board
            let possibleMoves = [];
            let originalBoard = "";
            let futureBoard = "";
            let trainingData = [];

            for (let i = 0; i < carlsenAsArray.length; i++) { //for every move that has been made in a game
                if (trainingLimitForTesting > 0) {
                    if (i >= trainingLimitForTesting) {
                        i = carlsenAsArray.length;
                    }
                }
                possibleMoves = game.moves();
                originalBoard = game.fen();
                //add training data//
                for (var v = 0; v < possibleMoves.length; v++) { //for every possible move for a particular board state
                    let possibleBoard = game.fen(); //gets the board as FEN from chess.js
                    let input = getNeuralInputFromFen();
                    //Finished with the input array

                    //adds training data
                    let tfinput = tf.tensor2d([input])
                    let target;

                    if (possibleMoves[v] == carlsenAsArray[i]) { //checks if the move is the one that was made in the original game
                        target = tf.tensor1d([1]);
                    } else {
                        target = tf.tensor1d([-1]);
                    }
                    const response = await model.fit([tfinput], [target] );
                    //console.log(response.history.loss[0]);
                    tf.dispose(tfinput);
                    tf.dispose(target);
                    //resets board
                    game.load(originalBoard);
                }
                //updates board for next move
                game.move(carlsenAsArray[i]);
            }
            
            finishedTraining();
        }
        */
        async function trainTheModel() {
            //do evolution
        }

        function CreatedNewModels() {
            console.log('Training has been finished!');
            console.log('Number of tensors not disposed: ' + tf.memory().numTensors);
            let fenTest = "rnbqkbnr/ppp1pppp/8/3p4/3P4/8/PPP1PPPP/RNBQKBNR w KQkq d6 0 1";
            game.load(fenTest);
            board = Chessboard('board', fenTest);
            /*let testArr = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 5, 0, 1, 0, 0, 1, 7, 0, 7, 1, 0, 0, 0, 7, 0, 11, 7, 0, 0, 7, 7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];	
            let tfTestArr = tf.tensor2d([testArr]);
            model.predict([tfTestArr]).print();
            tf.dispose(tfTestArr);*/
        }

        document.getElementById("startTheTraining").addEventListener("click", startTraining);

        function startTraining() {
            createTrainingData();
        }

        function getNeuralInputFromFen() {
            let newBoardAsArray = fenToArrayFunc(game.fen()); //translates the FEN board into an array
            //includes allowed castles and whose turn it is into the final array that will be the input for the NN
            let newBoardAsArrayNN = [];
            //finish the neuralnet final array
            for (var z = 0; z < 64; z++) {
                newBoardAsArrayNN[z] = newBoardAsArray[z];
            }
            let lastPartOfArray = "";
            for (var z = 64; z < newBoardAsArrayNN.length; z++) {
                lastPartOfArray += newBoardAsArrayNN[z];
            }
            if (lastPartOfArray.indexOf("w") != -1) {
                newBoardAsArrayNN.push(1);
            } //else it is black and value is 0
            else {
                newBoardAsArrayNN.push(0);
            }
            if (lastPartOfArray.indexOf("K") != -1) {
                newBoardAsArrayNN.push(1);
            } else {
                newBoardAsArrayNN.push(0);
            }
            if (lastPartOfArray.indexOf("Q") != -1) {
                newBoardAsArrayNN.push(1);
            } else {
                newBoardAsArrayNN.push(0);
            }
            if (lastPartOfArray.indexOf("k") != -1) {
                newBoardAsArrayNN.push(1);
            } else {
                newBoardAsArrayNN.push(0);
            }
            if (lastPartOfArray.indexOf("q") != -1) {
                newBoardAsArrayNN.push(1);
            } else {
                newBoardAsArrayNN.push(0);
            }

            return newBoardAsArrayNN;
        }

        document.getElementById("playBestMove").addEventListener("click", playBestMoveFunction);

        function playBestMoveFunction() {
            game.move(possibleMovesMonte[bestMoveIndex]);
            board = Chessboard('board', game.fen());
        }

        document.getElementById("predictBestMove").addEventListener("click", predictBestMoveFunction);

        function predictBestMoveFunction() {
            monteCarloTreeSearch(5);
        }

        document.getElementById("updateBoard").addEventListener("click", () => {
            board = Chessboard('board', game.fen());
        });
    </script>
    <script src="monteCarloTreeSearch.js"></script>
</body>

</html>